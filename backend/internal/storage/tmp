*   **Mechanism:** Create a background goroutine within your Go application that wakes up periodically (e.g., using `time.Ticker`) and executes the `REFRESH MATERIALIZED VIEW` command.
*   **Pros:**
    *   Keeps everything within your application.
    *   More control over the refresh process (e.g., you can easily stop, start, or adjust the frequency).
    *   Easier to monitor and log the refresh activity.
*   **Cons:**
    *   Adds a bit more complexity to your application code.
    *   You need to handle potential errors during the refresh process gracefully.

```go
package pg

import (
    "database/sql"
    "fmt"
    "log"
    "time"
)

func (s *Storage) StartPeriodicViewRefresh(interval time.Duration, boardShortNames ...string) {
    ticker := time.NewTicker(interval)
    go func() {
        for range ticker.C {
            for _, boardShortName := range boardShortNames {
                if err := s.refreshMaterializedView(boardShortName); err != nil {
                    log.Printf("Error refreshing materialized view for board %s: %v", boardShortName, err)
                }
            }
        }
    }()
}

func (s *Storage) refreshMaterializedView(boardShortName string) error {
    tx, err := s.db.Begin()
    if err != nil {
        return fmt.Errorf("failed to start transaction: %w", err)
    }
    defer tx.Rollback()
    viewName, err := getViewName(boardShortName)
    if err != nil {
        return fmt.Errorf("failed to get view name: %w", err)
    }
    if _, err := tx.Exec(fmt.Sprintf("REFRESH MATERIALIZED VIEW %s", viewName)); err != nil {
        return fmt.Errorf("failed to refresh materialized view: %w", err)
    }
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    log.Printf("Refreshed materialized view: %s", viewName)
    return nil
}

// in main function:
// storage.StartPeriodicViewRefresh(1 * time.Second, "tb", "b", "meta")
```